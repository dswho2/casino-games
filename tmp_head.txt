import { useEffect, useMemo, useRef, useState } from "react";
import { api } from "../../api/client";
import Button from "../../components/Button";
import ChipSelector from "../../components/ChipSelector";
import { useAuthStore } from "../../store/auth";

type Bet = { type: "straight" | "color"; target: string; amount_cents: number };

type WheelConfig = { pockets: string[]; step: number; assetOffsetRad: number };

type StartResp = { targetNumber: string; commitHash: string; spinId: number; wheelConfig: WheelConfig };
type SettleResp = { payouts: { selection: string; amount_wagered: number; multiple: number; win_amount: number }[]; newBalance: number; seed: string };

// European single-zero layout (clockwise from top 0)
const EURO_POCKETS = [
  "0",
  "32","15","19","4","21","2","25","17","34","6","27","13","36","11","30","8","23",
  "10","5","24","16","33","1","20","14","31","9","22","18","29","7","28","12","35","3","26",
];
const STEP = (Math.PI * 2) / EURO_POCKETS.length;
const WHEEL_ASSET_OFFSET = 0; // radians; set non-zero if art misaligned

type Phase = "betting" | "spinning" | "settling";

export default function RouletteTable() {
  const me = useAuthStore(s => s.me);
  const setMe = useAuthStore(s => s.setMe);
  const [phase, setPhase] = useState<Phase>("betting");
  const [bets, setBets] = useState<Bet[]>([]);
  const [selectedAmount, setSelectedAmount] = useState<number>(500); // cents
  const [error, setError] = useState<string | null>(null);

  // Round data
  const [spinId, setSpinId] = useState<number | null>(null);
  const [commitHash, setCommitHash] = useState<string | null>(null);
  const [seed, setSeed] = useState<string | null>(null);
  const [targetNumber, setTargetNumber] = useState<string | null>(null);
  const [wheelCfg, setWheelCfg] = useState<WheelConfig | null>(null);
  const [payouts, setPayouts] = useState<SettleResp["payouts"]>([]);

  const totalWager = useMemo(() => bets.reduce((s, b) => s + b.amount_cents, 0), [bets]);
  const maxPotential = useMemo(() => bets.reduce((s, b) => s + (b.type === "straight" ? b.amount_cents * 36 : b.amount_cents * 2), 0), [bets]);

  function addBet(b: Bet){
    if (phase !== "betting") return;
    setBets(prev => [...prev, b]);
  }
  function clearBets(){ if (phase === "betting") setBets([]); }

  // Animation refs
  const wheelRef = useRef<HTMLDivElement>(null);
  const ballRef = useRef<HTMLDivElement>(null);
  const glowRef = useRef<HTMLDivElement>(null);
  const hudTextRef = useRef<HTMLDivElement>(null);
  const rafRef = useRef<number>(0);

  // Audio: quiet tick using WebAudio oscillator
  const audioCtxRef = useRef<AudioContext | null>(null);
  function tickSound(){
    try {
      if (!audioCtxRef.current) audioCtxRef.current = new (window.AudioContext || (window as any).webkitAudioContext)();
      const ac = audioCtxRef.current!;
      const osc = ac.createOscillator();
      const gain = ac.createGain();
      osc.type = "square"; osc.frequency.value = 1200;
      gain.gain.value = 0.02;
      osc.connect(gain).connect(ac.destination);
      osc.start();
      osc.stop(ac.currentTime + 0.03);
    } catch {}
  }

  // Deterministic spin animation
  function runSpinAnimation(targetNum: string, cfg: WheelConfig){
    const pockets = cfg.pockets?.length ? cfg.pockets : EURO_POCKETS;
    const step = cfg.step || STEP;
    const assetOffset = (cfg.assetOffsetRad ?? WHEEL_ASSET_OFFSET);
    const targetIdx = pockets.indexOf(targetNum);
    const targetAngle = targetIdx >= 0 ? targetIdx * step : 0;

    const wheelStart = Math.random() * Math.PI * 2;
    const ballStart = Math.random() * Math.PI * 2;
    const wheelRevs = 2 + Math.floor(Math.random() * 2); // 2..3
    const duration = 6.5 * 1000;

    const wheelEnd = wheelStart + wheelRevs * Math.PI * 2;
    const ballEndBase = wheelEnd + targetAngle; // ensures relative landing
    const ballEnd = ballEndBase;

    const start = performance.now();
    let lastTickK = -1;

    cancelAnimationFrame(rafRef.current);
    const loop = (now: number) => {
      const t = Math.min(1, (now - start) / duration);
      const easeOut = 1 - Math.pow(1 - t, 3);
      const ballEase = 1 - Math.pow(1 - Math.min(1, t * 1.05), 3);
      // Small damped oscillation in last 12%
      const wobble = t > 0.88 ? (Math.sin((t - 0.88) * 30) * Math.exp(-(t - 0.88) * 24) * (step * 0.35)) : 0;

      const wheelAngle = wheelStart + (wheelEnd - wheelStart) * easeOut + assetOffset;
      const ballAngle = ballStart + (ballEnd - ballStart) * ballEase + wobble + assetOffset;

      // Tick when passing pocket separators based on (ball - wheel) / step
      const rel = (ballAngle - wheelAngle) / step;
      const k = Math.floor(rel);
      if (k !== lastTickK) { lastTickK = k; tickSound(); }

      // Blur wheel more when fast (early t)
      const blur = (1 - easeOut) * 3.5; // px
      if (wheelRef.current) {
        const deg = (wheelAngle * 180) / Math.PI;
        wheelRef.current.style.transform = `rotate(${deg}deg)`;
        wheelRef.current.style.filter = `blur(${blur.toFixed(2)}px)`;
      }
      if (ballRef.current) {
        const deg = (ballAngle * 180) / Math.PI;
        const radius = 120; // px from center
        const x = Math.cos(ballAngle) * radius;
        const y = Math.sin(ballAngle) * radius;
        ballRef.current.style.transform = `translate(${x}px, ${y}px) rotate(${deg}deg)`;
      }
      if (glowRef.current) {
        const deg = ((wheelStart + (wheelEnd - wheelStart) * easeOut + targetAngle + assetOffset) * 180) / Math.PI;
        glowRef.current.style.transform = `translate(-50%, -50%) rotate(${deg}deg)`;
        glowRef.current.style.opacity = t > 0.9 ? "1" : "0";
      }
      if (hudTextRef.current) {
        const remaining = Math.max(0, duration - (now - start));
        hudTextRef.current.textContent = t < 1 ? `Spinningâ€¦ ${(remaining/1000).toFixed(1)}s` : `Result: ${targetNum}`;
      }

      if (t < 1) rafRef.current = requestAnimationFrame(loop);
      else {
        cancelAnimationFrame(rafRef.current);
        onSpinComplete();
      }
    };
    rafRef.current = requestAnimationFrame(loop);
  }

  async function onSpinComplete(){
    try {
      if (!spinId) return;
      const res = await api<SettleResp>(`/roulette/settle`, { method: "POST", body: JSON.stringify({ spinId }) });
      setSeed(res.seed);
      setPayouts(res.payouts);
      if (me) setMe({ ...me, balance_cents: res.newBalance });
      setPhase("settling");
    } catch (e: any) {
      setError(e?.message || "Failed to settle");
      setPhase("betting");
    }
  }

  async function submitBets(){
    setError(null);
    if (phase !== "betting") return;
    if (bets.length === 0) { setError("Place at least one bet"); return; }
    try {
      setPhase("spinning");
      const body = { tableId: "main", bets: bets.map(b => ({ type: b.type, target: b.target, amount_cents: b.amount_cents })) };
      const res = await api<StartResp>(`/roulette/start`, { method: "POST", body: JSON.stringify(body) });
      setCommitHash(res.commitHash);
      setSpinId(res.spinId);
      setTargetNumber(res.targetNumber);
      setWheelCfg(res.wheelConfig);
      // Fire the animation deterministically
      runSpinAnimation(res.targetNumber, res.wheelConfig || { pockets: EURO_POCKETS, step: STEP, assetOffsetRad: WHEEL_ASSET_OFFSET });
    } catch (e: any) {
      setError(e?.message || "Failed to start roulette round");
      setPhase("betting");
    }
  }

  function nextRound(){
    setPhase("betting");
    setBets([]);
    setSpinId(null); setCommitHash(null); setSeed(null); setTargetNumber(null);
    setPayouts([]);
  }

  useEffect(() => () => cancelAnimationFrame(rafRef.current), []);

  // UI helpers
  const canSubmit = phase === "betting" && bets.length > 0 && totalWager > 0;
  const targetColor = targetNumber ? (targetNumber === "0" ? "G" : (Number(targetNumber) % 2 === 0 ? "B" : "R")) : null;

  return (
    <div className="grid grid-cols-1 lg:grid-cols-[minmax(280px,520px)_1fr] gap-6">
      {/* Left: Wheel */}
      <div className="relative rounded-2xl bg-card/70 border border-white/10 p-4">
        <div className="text-lg font-semibold mb-3">Wheel</div>
        <div className="relative mx-auto" style={{ width: 320, height: 320 }}>
          {/* Centered origin wrapper (fixed size to avoid 0x300 issue) */}
          <div className="absolute left-1/2 top-1/2 relative" style={{ transform: "translate(-50%, -50%)", width: 300, height: 300 }}>
            <div ref={wheelRef} className="will-change-transform absolute inset-0" style={{ transformOrigin: '50% 50%' }}>
              <img src="/roulette/roulette_wheel.webp" alt="Roulette Wheel" width={300} height={300} draggable={false} style={{ width: 300, height: 300, display: 'block' }} onError={(e) => { (e.currentTarget as HTMLImageElement).style.visibility = 'hidden'; }} />
            </div>
            {/* Winner glow wedge */}
            <div ref={glowRef} className="pointer-events-none absolute left-1/2 top-1/2 will-change-transform" style={{ width: 300, height: 300, transform: 'translate(-50%, -50%)', opacity: 0 }}>
              <div className="absolute left-1/2 top-1/2" style={{ transform: 'translate(-50%, -50%)' }}>
                <div style={{ width: 300, height: 300, borderRadius: '50%', background: 'conic-gradient(from 0deg, rgba(255,255,255,0) 0deg, rgba(255,255,255,0) 174deg, rgba(255,255,255,0.25) 180deg, rgba(255,255,255,0) 186deg, rgba(255,255,255,0) 360deg)' }} />
              </div>
            </div>
            {/* Ball */}
            <div ref={ballRef} className="absolute left-1/2 top-1/2 will-change-transform" style={{ width: 10, height: 10, marginLeft: -5, marginTop: -5, borderRadius: 9999, background: '#fafafa', boxShadow: '0 0 6px rgba(255,255,255,0.7), 0 0 14px rgba(255,255,255,0.35)' }} />
          </div>
          {/* HUD */}
          <div className="absolute bottom-2 left-2 right-2 text-center text-sm text-white/80">
            <div ref={hudTextRef}>{phase === 'spinning' ? 'Spinningâ€¦' : phase === 'settling' ? (targetNumber ? `Result: ${targetNumber}` : '') : 'Place your bets'}</div>
          </div>
        </div>
      </div>

      {/* Right: Betting + Summary */}
      <div className="flex flex-col gap-4">
        {/* Bets panel */}
        <div className="rounded-2xl bg-card/70 border border-white/10 p-4">
          <div className="flex items-center justify-between mb-3">
            <div className="text-lg font-semibold">Bets</div>
            {phase === 'betting' && (
              <button onClick={clearBets} className="text-white/70 hover:text-white text-sm">Clear</button>
            )}
          </div>
          <div className="mb-3">
            <ChipSelector onChange={setSelectedAmount} />
          </div>
          <div className="grid grid-cols-12 gap-1 select-none">
            {/* 0 cell spanning 2 columns */}
            <BetCell disabled={phase!=="betting"} label="0" color="G" onClick={() => addBet({ type: 'straight', target: '0', amount_cents: selectedAmount })} className="col-span-2" />
            {/* 1..36 cells */}
            {Array.from({ length: 36 }).map((_, i) => {
              const n = (i + 1).toString();
              const color = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36].includes(i+1) ? 'R' : 'B';
              return (
                <BetCell key={n} disabled={phase!=="betting"} label={n} color={color} onClick={() => addBet({ type: 'straight', target: n, amount_cents: selectedAmount })} />
              );
            })}
          </div>
